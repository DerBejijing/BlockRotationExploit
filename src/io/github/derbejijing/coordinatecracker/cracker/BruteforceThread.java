package io.github.derbejijing.coordinatecracker.cracker;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.text.DecimalFormat;
import java.util.List;

import io.github.derbejijing.coordinatecracker.Main;
import io.github.derbejijing.coordinatecracker.data.EnumMCVersion;
import io.github.derbejijing.coordinatecracker.data.EnumRotation;
import io.github.derbejijing.coordinatecracker.data.PatternRelative;
import io.github.derbejijing.coordinatecracker.math.Matrix3;
import io.github.derbejijing.coordinatecracker.math.Vector3;
import io.github.derbejijing.coordinatecracker.utils.MathHelper;
import io.github.derbejijing.coordinatecracker.utils.VectorHelper;

public class BruteforceThread extends Thread {

	private final PatternRelative scope;
	
	private Vector3 start;
	private Vector3 end;
	
	private final EnumMCVersion version;
	private final EnumRotation rotation;
	
	private final CoordinateBruteforcer coordinateBruteforcer;

	private final Main instance;
	
	private final int id;
	
	public BruteforceThread(PatternRelative scope, Vector3 start, Vector3 end, EnumMCVersion version, EnumRotation rotation, Main instance, CoordinateBruteforcer coordinateBruteforcer, int id) {
		this.scope = scope;
		this.start = start;
		this.end = end;
		this.version = version;
		this.rotation = rotation;
		this.instance = instance;
		this.coordinateBruteforcer = coordinateBruteforcer;
		this.id = id;
	}
	
	public void run() {
		System.out.println("Thread[" + this.id + "] Starting new bruteforce thread with id [" + this.id + "]");
		System.out.println("Thread[" + this.id + "] Start: [" +
		start.getX() + " : " +
		start.getY() + " : " +
		start.getZ() + "], End: [" + 
		end.getX() + " : " +
		end.getY() + " : " +
		end.getZ() + "]");
		
		List<Vector3> tmp = VectorHelper.adjustStartEndVectors(start, end);
		this.start = tmp.get(0);
		this.end = tmp.get(1);
		
		int matches = 0;
		long progress = 0;
		long entireIterationsCount = MathHelper.getValue(end.getX() - start.getX()) * MathHelper.getValue(end.getY() - start.getY()) * MathHelper.getValue(end.getZ() - start.getZ()); 
		
		for(int x = start.getX(); x < end.getX(); x++) {
			for(int y = start.getY(); y < end.getY(); y++) {
				
				
				for(int z = start.getZ(); z < end.getZ(); z++) {
					if(this.rotation == EnumRotation.R_ALL) {
						for(Matrix3 currentScope : scope.getPatterns()) {	
							if(this.matchesPattern(new Vector3(x, y, z), currentScope)) {
								System.out.println(x +  " " + y + " " + z);
								this.saveCoordinates(this.instance.getSaveFile(), new Vector3(x, y, z));
								this.instance.updateMatchesCount(matches);
								matches++;
							}
						}
					} else {
						if(this.matchesPattern(new Vector3(x, y, z), this.scope.getPatternMatrix(this.rotation))) {
							System.out.println(x +  " " + y + " " + z);
							this.saveCoordinates(this.instance.getSaveFile(), new Vector3(x, y, z));
							this.instance.updateMatchesCount(matches);
							matches++;
						}
					}
					++progress;
				}
				this.instance.updateProgress((int) ((int) (progress * 100)/entireIterationsCount));
			}
		}
		
		System.out.println("Thread[" + this.id + "] Done with " + matches + " matches!");
		this.coordinateBruteforcer.setDone(this);
		
	}
	
	private boolean matchesPattern(Vector3 posIn, Matrix3 pattern) {
		Vector3 center = pattern.getCenter();
		boolean matches = true;
		
		for(int x = 0; x < pattern.getSizeX(); x++) {
			for(int y = 0; y < pattern.getSizeY(); y++) {
				for(int z = 0; z < pattern.getSizeZ(); z++) {
					
					if(pattern.getValue(new Vector3(x, y, z)) != 4) {
						Vector3 difference = new Vector3(x + center.getX(), y + center.getY(), z + center.getZ());
						difference = difference.multiply(new Vector3(-1, -1, -1));
					
						Vector3 lookupPosition = new Vector3(posIn.getX() + difference.getX(), posIn.getY() + difference.getY(), posIn.getZ() + difference.getZ());
						
						int valueWanted = pattern.getValue(new Vector3(x, y, z));
						int valueReal = this.version == EnumMCVersion.V1_12_2 ? MathHelper.getRotationForVector(lookupPosition) : MathHelper.getRotationForVector_1_16(lookupPosition);
						
						if((valueReal != valueWanted)) matches = false;
					}		
				}
			}
		}
		
		return matches;
		
	}
	
	private void saveCoordinates(String path, Vector3 vecor) {
		try {
			File f = new File(path);
			if(!f.exists()) { 
		    	f.createNewFile();
			}
		
			FileWriter fileWriter = new FileWriter(path, true);
			BufferedWriter bufferedWriter = new BufferedWriter(fileWriter);
			bufferedWriter.write(vecor.getX() + " " + vecor.getY() + " " + vecor.getZ());
			bufferedWriter.newLine();
			bufferedWriter.close();
		} catch(Exception e) {
			e.printStackTrace();
		}
	}
	
}
