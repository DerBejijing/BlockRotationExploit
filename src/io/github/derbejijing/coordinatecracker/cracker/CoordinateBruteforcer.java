package io.github.derbejijing.coordinatecracker.cracker;

import java.util.ArrayList;
import java.util.List;
import io.github.derbejijing.coordinatecracker.Main;
import io.github.derbejijing.coordinatecracker.data.EnumMCVersion;
import io.github.derbejijing.coordinatecracker.data.EnumRotation;
import io.github.derbejijing.coordinatecracker.data.PatternRelative;
import io.github.derbejijing.coordinatecracker.math.Vector3;
import io.github.derbejijing.coordinatecracker.utils.SystemHelper;

public class CoordinateBruteforcer {
	
	private List<BruteforceThread> bruteforceThreads;
	
	private final PatternRelative scope;
	
	private final int radius;
	private final int y_start;
	private final int y_end;
	
	private final EnumMCVersion version;
	private final EnumRotation rotation;
	
	private Main mainInstance;
	
	private final int threads;
	private int matches;
	
	public CoordinateBruteforcer(PatternRelative scope, int radius, int y_start, int y_end, EnumMCVersion version, EnumRotation rotation, Main mainInstance, int threads) {
		this.scope = scope;
		this.radius = radius;
		this.y_start = y_start;
		this.y_end = y_end;
		this.version = version;
		this.rotation = rotation;
		this.mainInstance = mainInstance;
		this.threads = SystemHelper.adjustThreadCount(threads);
		
		this.matches = 0;
	}
	
	public CoordinateBruteforcer(PatternRelative scope, int radius, EnumMCVersion version, EnumRotation rotation, Main mainInstance, int threads) {
		this(scope, radius, 0, 256, version, rotation, mainInstance, threads);
	}
	
	public void load() {
		bruteforceThreads = new ArrayList<>();
		
		System.out.println(mainInstance.getSaveFile());
		this.loadThreads(this.threads);
		
		this.crack();
	}
	
	@SuppressWarnings("deprecation")
	public void veryVeryBadTermination() {
		for(BruteforceThread bt : this.bruteforceThreads) {
			bt.stop();
		}
	}
	
	
	public void setDone(BruteforceThread b) {
		for(BruteforceThread bt : this.bruteforceThreads) {
			if(bt != b && bt.isAlive()) return;
		}
		
		this.mainInstance.crackingEnd();
	}
	
	
	public void updateMatchesCount() {
		++this.matches;
		this.mainInstance.updateMatchesCount(this.matches);
	}
	
	private void loadThreads(int threadcount) {
		switch(threadcount) {
		case 1:
			bruteforceThreads.add(new BruteforceThread(scope, new Vector3(radius * -1, y_start, radius * -1), new Vector3(radius, y_end, radius), this.version, this.rotation, this.mainInstance,  this, 1));
			break;
		
		case 2:
			bruteforceThreads.add(new BruteforceThread(scope, new Vector3(radius * -1, y_start, radius * -1), new Vector3(0, y_end, 0), this.version, this.rotation, this.mainInstance, this, 1));
			bruteforceThreads.add(new BruteforceThread(scope, new Vector3(1, y_start, 1), new Vector3(radius, y_end, radius), this.version, this.rotation, this.mainInstance, this, 2));
			break;
			
		case 4:
			bruteforceThreads.add(new BruteforceThread(scope, new Vector3(0, y_start, 0), new Vector3(radius, y_end, radius), this.version, this.rotation, this.mainInstance, this, 1));
			bruteforceThreads.add(new BruteforceThread(scope, new Vector3(0, y_start, -1), new Vector3(radius, y_end, radius * -1), this.version, this.rotation, this.mainInstance, this, 2));
			bruteforceThreads.add(new BruteforceThread(scope, new Vector3(-1, y_start, -1), new Vector3(radius * -1, y_end, radius * -1), this.version, this.rotation, this.mainInstance, this, 3));
			bruteforceThreads.add(new BruteforceThread(scope, new Vector3(-1, y_start, 0), new Vector3(radius * -1, y_end, radius), this.version, this.rotation, this.mainInstance, this, 4));
			break;
			
		case 8:
			break;
		default:
			loadThreads(1);
			break;
		}
	}
	
	private void crack() {
		for(BruteforceThread bt : this.bruteforceThreads) {
			bt.start();
		}
	}
	
}
