package io.github.derbejijing.coordinatecracker.cracker;

import java.util.ArrayList;
import java.util.List;
import io.github.derbejijing.coordinatecracker.Main;
import io.github.derbejijing.coordinatecracker.data.EnumMCVersion;
import io.github.derbejijing.coordinatecracker.data.EnumRotation;
import io.github.derbejijing.coordinatecracker.data.PatternRelative;
import io.github.derbejijing.coordinatecracker.math.Vector3;
import io.github.derbejijing.coordinatecracker.utils.SystemHelper;

public class CoordinateBruteforcer {
	
	private List<BruteforceThread> bruteforceThreads;
	
	private final PatternRelative scope;
	
	private final int radius;
	private final int y_start;
	private final int y_end;
	
	private final EnumMCVersion version;
	private final EnumRotation rotation;
	
	private Main mainInstance;
	
	private final int threads;
	private int matches;
	
	/**
	* CoordinateBruteforcer constructor
	* scope: pattern to search for
	* radius: how far to go away from (0,0)
	* y_start: minimum y-value
	* y_end: maximum y-value
	* version: minecraft version
	* rotation: rotation the pattern is facing. R_ALL means all rotations
	* mainInstance: instance of main
	* threads: number of threads to use for cracking
	*/
	public CoordinateBruteforcer(PatternRelative scope, int radius, int y_start, int y_end, EnumMCVersion version, EnumRotation rotation, Main mainInstance, int threads) {
		this.scope = scope;
		this.radius = radius;
		this.y_start = y_start;
		this.y_end = y_end;
		this.version = version;
		this.rotation = rotation;
		this.mainInstance = mainInstance;
		this.threads = SystemHelper.adjustThreadCount(threads);
		
		this.matches = 0;
	}
	
	
	/**
	* CoordinateBruteforcer constructor
	* scope: pattern to search for
	* radius: how far to go away from (0,0)
	* version: minecraft version
	* rotation: rotation the pattern is facing. R_ALL means all rotations
	* mainInstance: instance of main
	* threads: number of threads to use for cracking
	*/
	public CoordinateBruteforcer(PatternRelative scope, int radius, EnumMCVersion version, EnumRotation rotation, Main mainInstance, int threads) {
		this(scope, radius, 0, 256, version, rotation, mainInstance, threads);
	}
	
	
	/**
	* Setup threads
	*/
	public void load() {
		bruteforceThreads = new ArrayList<>();
		this.loadThreads(this.threads);
		this.crack();
	}
	
	
	/**
	* Kill running threads in the worst possible way
	*/
	@SuppressWarnings("deprecation")
	public void veryVeryBadTermination() {
		for(BruteforceThread bt : this.bruteforceThreads) {
			bt.stop();
		}
	}
	
	
	/**
	* BruteforceThreads call this if they are done
	* calls Main#crackingEnd() if all threads are done
	* b: BruteforceThread calling the methd
	*/
	public void setDone(BruteforceThread b) {
		for(BruteforceThread bt : this.bruteforceThreads) {
			if(bt != b && bt.isAlive()) return;
		}
		
		this.mainInstance.crackingEnd();
	}
	
	
	/**
	* Update matches count
	* called by each BruteforceThread
	*/
	public void updateMatchesCount() {
		++this.matches;
		this.mainInstance.updateMatchesCount(this.matches);
	}
	
	
	/**
	* Sets up all threads, fair distribution of region to crack
	*/
	private void loadThreads(int threadcount) {
		switch(threadcount) {
		case 1:
			bruteforceThreads.add(new BruteforceThread(scope, new Vector3(radius * -1, y_start, radius * -1), new Vector3(radius, y_end, radius), this.version, this.rotation, this.mainInstance,  this, 1));
			break;
		
		case 2:
			bruteforceThreads.add(new BruteforceThread(scope, new Vector3(radius * -1, y_start, radius * -1), new Vector3(0, y_end, 0), this.version, this.rotation, this.mainInstance, this, 1));
			bruteforceThreads.add(new BruteforceThread(scope, new Vector3(1, y_start, 1), new Vector3(radius, y_end, radius), this.version, this.rotation, this.mainInstance, this, 2));
			break;
			
		case 4:
			bruteforceThreads.add(new BruteforceThread(scope, new Vector3(0, y_start, 0), new Vector3(radius, y_end, radius), this.version, this.rotation, this.mainInstance, this, 1));
			bruteforceThreads.add(new BruteforceThread(scope, new Vector3(0, y_start, -1), new Vector3(radius, y_end, radius * -1), this.version, this.rotation, this.mainInstance, this, 2));
			bruteforceThreads.add(new BruteforceThread(scope, new Vector3(-1, y_start, -1), new Vector3(radius * -1, y_end, radius * -1), this.version, this.rotation, this.mainInstance, this, 3));
			bruteforceThreads.add(new BruteforceThread(scope, new Vector3(-1, y_start, 0), new Vector3(radius * -1, y_end, radius), this.version, this.rotation, this.mainInstance, this, 4));
			break;
			
		case 8:
			break;
		default:
			loadThreads(1);
			break;
		}
	}
	
	
	/**
	* Starts all threads
	*/
	private void crack() {
		for(BruteforceThread bt : this.bruteforceThreads) {
			bt.start();
		}
	}
	
}
