 package io.github.derbejijing.coordinatecracker;

import java.awt.EventQueue;
import java.awt.Image;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.border.BevelBorder;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;

import io.github.derbejijing.coordinatecracker.cracker.CoordinateBruteforcer;
import io.github.derbejijing.coordinatecracker.data.EnumMCVersion;
import io.github.derbejijing.coordinatecracker.data.EnumMode;
import io.github.derbejijing.coordinatecracker.data.EnumReason;
import io.github.derbejijing.coordinatecracker.data.EnumRotation;
import io.github.derbejijing.coordinatecracker.data.PatternRelative;
import io.github.derbejijing.coordinatecracker.gui.ErrorPopup;
import io.github.derbejijing.coordinatecracker.math.Matrix3;
import io.github.derbejijing.coordinatecracker.math.Vector2;
import io.github.derbejijing.coordinatecracker.math.Vector3;
import io.github.derbejijing.coordinatecracker.utils.MathHelper;

import javax.swing.JButton;
import javax.swing.JSpinner;
import javax.swing.SpinnerNumberModel;
import javax.swing.JLabel;
import javax.swing.JComboBox;
import javax.swing.JFileChooser;
import javax.swing.DefaultComboBoxModel;
import javax.swing.ImageIcon;
import javax.swing.JTextField;
import javax.swing.SpinnerModel;
import java.awt.Color;
import javax.swing.ComboBoxModel;

@SuppressWarnings("unused")
public class Main implements ActionListener{

	private static EnumMode programMode;
	
	private static final int VERSION_MAJOR = 6;
	private static final int VERSION_MINOR = 0;
	private static final int PATTERN_SIZE = 7;
	private static final int PATTERN_CENTER = 4;
	
	private static final int masterArgsMin = 1;
	private static final int slaveArgsMin = 2;
	
	private static int PORT;
	private static int MAXCONS;
	private static String KEY;
	private static String MASTERHOST;
	
	private static Main instance;
	
	private JFrame frame;
	
	private List<JButton> fieldButtons;
	
	private JButton btnStartCracking;
	private JButton btnRotateRight;
	private JButton btnSetTextured;
	private JButton btnLoadPatternFile;
	private JButton btnChooseFilename;
	
	private JTextField saveResultsField;
	
	private JButton btnApply;
	
	private JSpinner ySpinnerMin;
	private JSpinner ySpinnerMax;
	
	private JLabel lblProgress;
	private JLabel lblTotalMatches;
	
	private Vector2 activeField;
	
	private Matrix3 pattern;
	
	private boolean crackerRunning;
	private boolean crackerEnabled;
	private boolean validYMin;
	private boolean validYMax;
	private boolean validRadius;
	
	private int currentLayer;
	
	private ImageIcon icon_0;
	private ImageIcon icon_1;
	private ImageIcon icon_2;
	private ImageIcon icon_3;
	
	private int yMin;
	private int yMax;
	private int radius;
	
	private int threadCount;
	
	private String saveResultsPath;
	
	private CoordinateBruteforcer cb;
	
	private EnumMCVersion mcVersion;
	
	private EnumRotation rotation;
	private JTextField radiusTextField;
	
	/**
	* Main entrypoint
	*/
	public static void main(String[] args) {
		ArrayList<String> arguments = new ArrayList<>(Arrays.asList(args));
		programMode = EnumMode.SINGLE;
		
		/**
		* Argument Parsing. currently without any function
		* Modes: master/slave or none (normal)
		*/
		if(args.length > 0) {
			// Check for master argument
			if(args[0].equalsIgnoreCase("master") || args[0].equalsIgnoreCase("--master")) {
				int argsSpecified = 0;
				
				String port = parseArgument(arguments, "port");
				if(port != "") {
					PORT = (MathHelper.isInteger(port) ? Integer.valueOf(port) : -1);
					if(PORT > 0) ++argsSpecified;
					
					System.out.println("Port: " + port);
				}
				
				String key = parseArgument(arguments, "key");
				if(key != "") {
					System.out.println("Key: " + key);
				}
				
				String maxcons = parseArgument(arguments, "maxcons");
				if(maxcons != "") {
					System.out.println("Maximum connections: " + maxcons);
				}
				
				if(argsSpecified >= masterArgsMin) programMode = EnumMode.MASTER;
				else showMasterHelp(EnumReason.COUNT);
			}
			// Check for slave argument
			else if(args[0].equalsIgnoreCase("slave") || args[0].equalsIgnoreCase("--slave")) {
				int argsSpecified = 0;
				
				String host = parseArgument(arguments, "host");
				if(host != "") {
					if(host.matches("\\b((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.|$)){4}\\b")) {
						MASTERHOST = host;
						++argsSpecified;
					}
					System.out.println("Host: " + host);
				}
				
				String port = parseArgument(arguments, "port");
				if(port != "") {
					PORT = (MathHelper.isInteger(port) ? Integer.valueOf(port) : -1);
					if(PORT > 0) ++argsSpecified;
					
					System.out.println("Port: " + port);
				}
				
				String key = parseArgument(arguments, "key");
				if(key != "") {
					System.out.println("Key: " + key);
				}
				
				if(argsSpecified >= slaveArgsMin) programMode = EnumMode.SLAVE;
				else showSlaveHelp(EnumReason.COUNT);
			}
			else if(args[0].equalsIgnoreCase("help") || args[0].equalsIgnoreCase("--help")) {
				showHelpMenu();
			}
			else showHelpMenu();
		}
		
		// Default-mode
		if(programMode == EnumMode.SINGLE) {
			EventQueue.invokeLater(new Runnable() {
				public void run() {
					try {
						Main window = new Main();
						window.frame.setVisible(true);
					} catch (Exception e) {
						new ErrorPopup().showPopup();
					}
				}
			});
		}
		
		// Master-mode
		if(programMode == EnumMode.MASTER) {
			EventQueue.invokeLater(new Runnable() {
				public void run() {
					try {
						System.out.println("Starting master on port: " + PORT);
					} catch(Exception e) {
						
					}
				}
			});
		}
		
		// Slave-mode
		if(programMode == EnumMode.SLAVE) {
			EventQueue.invokeLater(new Runnable() {
				
				@Override
				public void run() {
				}
			});;
		}
		
	}
	
	
	/**
	* Main constructor
	*/
	public Main() {
		initialize();
	}

	
	/**
	* Function for parsing arguments.
	* arguments: List of arguments given to the program
	* argument: argument to search for
	*
	* returns argument value, if given
	*/
	private static String parseArgument(ArrayList<String> arguments, String argument) {
		if(arguments.contains(argument) || arguments.contains("--" + argument)) {
			try {
				int index = arguments.indexOf(argument);
				if(index < 0) index = arguments.indexOf("--" + argument);
				if(arguments.size() > index + 1) {
					return arguments.get(index + 1);
				}
			} catch(Exception e) {
				return "";
			}
		}
		return "";
		
	}
	
	
	/**
	* Shows help menu explaining master, slave and normal mode
	*/
	private static void showHelpMenu() {
		System.out.println("-----[ HELP MENU ]-----");
		System.out.println("Run without arguments to start in single-mode");
		System.out.println("");
		System.out.println("Arguments:");
		System.out.println(" --help        : Shows this help menu");
		System.out.println(" --master      : The program starts as master instance over computing instances (slaves)");
		System.out.println(" --slave       : The program starts as a computing instance controlled by a master");
		programMode = EnumMode.DIE;
	}
	
	
	/**
	* Shows help menu explaining master-mode arguments.
	* reason: Reason for the help menu to appear 
	*/
	private static void showMasterHelp(EnumReason reason) {
		System.out.println("-----[ MASTER MODE HELP MENU ]-----");
		System.out.println(reason == EnumReason.NONE ? "" : reason.description + "\n");
		System.out.println("Arguments:");
		System.out.println("  name         : required : description");
		System.out.println(" --port <port> :        * : Set the port on which the server will listen on for clients");
		System.out.println(" --key <key>   :          : Set a string every slave has to use");
		System.out.println("                            That way you can prevent evil persons from manipulating the cracking procedure");
		System.out.println(" --maxcons <n> :          : Set a limit to how many slaves are allowed to connect");
		System.out.println("                            Depends on masters network-speed and computing-power");
		programMode = EnumMode.DIE;
	}
	
	
	/**
	* Shows help menu explaining slave-mode arguments.
	* reason: Reason for the help menu to appear 
	*/
	private static void showSlaveHelp(EnumReason reason) {
		System.out.println("-----[ SLAVE HELP MENU ]-----");
		System.out.println(reason == EnumReason.NONE ? "" : reason.description + "\n");
		System.out.println("Arguments:");
		System.out.println("  name         : required : description");
		System.out.println(" --host <host> :        * : IP/domain. Masters host address");
		System.out.println(" --port <port> :        * : Port on which the master is listening on");
		System.out.println(" --key <key>   :          : Specify the key wanted by the master node");
		programMode = EnumMode.DIE;
	}
	
	
	/**
	* Initialize variables, objects and setup GUI
	*/
	@SuppressWarnings({ "unchecked", "rawtypes" })
	private void initialize() {
		instance = this;
		
		this.fieldButtons = new ArrayList<>();
		this.activeField = new Vector2(3, 3);
		this.pattern = new Matrix3(new Vector3(PATTERN_SIZE, PATTERN_SIZE, PATTERN_SIZE), new Vector3(PATTERN_CENTER, PATTERN_CENTER, PATTERN_CENTER));
		
		for(int x = 0; x < PATTERN_SIZE; ++x) {
			for(int y = 0; y < PATTERN_SIZE; ++y) {
				for(int z = 0; z < PATTERN_SIZE; ++z) {
					this.pattern.setValue(new Vector3(x, y, z), 4);
				}
			}
		}
		
		this.currentLayer = 1;
		
		this.icon_0 = new ImageIcon(getClass().getClassLoader().getResource("io/github/derbejijing/coordinatecracker/icons/grass_top_0.png"));
		this.icon_1 = new ImageIcon(getClass().getClassLoader().getResource("io/github/derbejijing/coordinatecracker/icons/grass_top_1.png"));
		this.icon_2 = new ImageIcon(getClass().getClassLoader().getResource("io/github/derbejijing/coordinatecracker/icons/grass_top_2.png"));
		this.icon_3 = new ImageIcon(getClass().getClassLoader().getResource("io/github/derbejijing/coordinatecracker/icons/grass_top_3.png"));
		
		this.cb = null;
		
		this.crackerEnabled = true;
		
		this.yMin = 0;
		this.yMax = 256;
		this.radius = 100;
		
		this.validYMin = true;
		this.validYMax = true;
		this.validRadius = true;
		
		this.threadCount = 1;
		
		this.rotation = EnumRotation.R_ALL;
		
		frame = new JFrame("CoordinateCracker_v" + Main.VERSION_MAJOR + " by DerBejijing");
		frame.setBounds(100, 100, 1104, 609);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.getContentPane().setLayout(null);
		frame.setResizable(false);
		
		JPanel panelMain = new JPanel();
		panelMain.setBounds(12, 0, 1080, 567);
		frame.getContentPane().add(panelMain);
		panelMain.setLayout(null);
		
		JPanel panelCreatePattern = new JPanel();
		panelCreatePattern.setBorder(new BevelBorder(BevelBorder.LOWERED, null, null, null, null));
		panelCreatePattern.setBounds(12, 12, 465, 543);
		panelMain.add(panelCreatePattern);
		panelCreatePattern.setLayout(null);
		
		SpinnerModel values = new SpinnerNumberModel(1, 1, PATTERN_SIZE, 1);
		JSpinner spinner = new JSpinner(values);
		spinner.setBounds(66, 509, 79, 20);
		spinner.addChangeListener(new ChangeListener() {
			@Override
			public void stateChanged(ChangeEvent e) {
				currentLayer = (int) spinner.getValue();
				System.out.println("Rendering");
				
				renderLayer(currentLayer);
			}
		});
		panelCreatePattern.add(spinner);
		
		JLabel lblLayer = new JLabel("Layer:");
		lblLayer.setBounds(10, 511, 68, 15);
		panelCreatePattern.add(lblLayer);
		
		btnRotateRight = new JButton("Rotate tile");
		btnRotateRight.setBounds(165, 481, 150, 25);
		btnRotateRight.addActionListener(this);
		panelCreatePattern.add(btnRotateRight);
		
		JPanel panel_4 = new JPanel();
		panel_4.setBorder(new BevelBorder(BevelBorder.LOWERED, null, null, null, null));
		panel_4.setBounds(63, 51, 350, 350);
		panelCreatePattern.add(panel_4);
		panel_4.setLayout(null);
		
		btnSetTextured = new JButton("Set Textured");
		btnSetTextured.setBounds(12, 481, 150, 25);
		btnSetTextured.addActionListener(this);
		panelCreatePattern.add(btnSetTextured);
		
		JLabel lblDirectionIndicator = new JLabel("West");
		lblDirectionIndicator.setBounds(215, 24, 40, 15);
		panelCreatePattern.add(lblDirectionIndicator);
		
		// TODO: make dependent on PATTERN_SIZE
		for(int x = 0; x < 350; x += 50) {
			for(int y = 0; y < 350; y += 50) {
				JButton button = new JButton("");
				button.setBackground(Color.GRAY);
				button.setBounds(x, y, 50, 50);
				button.addActionListener(this);
				this.fieldButtons.add(button);
				panel_4.add(button);
			}
		}
		
		JPanel panelCracking = new JPanel();
		panelCracking.setBorder(new BevelBorder(BevelBorder.LOWERED, null, null, null, null));
		panelCracking.setBounds(777, 12, 277, 543);
		panelMain.add(panelCracking);
		panelCracking.setLayout(null);
		
		JLabel lblOptions = new JLabel("Cracking Options");
		lblOptions.setBounds(12, 12, 253, 15);
		panelCracking.add(lblOptions);
		
		JPanel panelCracking_threads = new JPanel();
		panelCracking_threads.setBorder(new BevelBorder(BevelBorder.LOWERED, null, null, null, null));
		panelCracking_threads.setBounds(0, 35, 277, 100);
		panelCracking.add(panelCracking_threads);
		panelCracking_threads.setLayout(null);
		
		JLabel lblNumberOfThreads = new JLabel("Number of Threads: ");
		lblNumberOfThreads.setBounds(12, 12, 181, 15);
		panelCracking_threads.add(lblNumberOfThreads);
		
		JComboBox comboBox = new JComboBox(new DefaultComboBoxModel(new String[] {"1", "2", "4"}));
		comboBox.setBounds(12, 39, 83, 24);
		comboBox.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent arg0) {
				JComboBox cb = (JComboBox) arg0.getSource();
				
				threadCount = Integer.valueOf(cb.getSelectedItem().toString());
			}
		});
		panelCracking_threads.add(comboBox);
		
		JPanel panelCrackingSaveResults = new JPanel();
		panelCrackingSaveResults.setLayout(null);
		panelCrackingSaveResults.setBorder(new BevelBorder(BevelBorder.LOWERED, null, null, null, null));
		panelCrackingSaveResults.setBounds(0, 140, 277, 100);
		panelCracking.add(panelCrackingSaveResults);
		
		JLabel lblSaveResults = new JLabel("Save Results: ");
		lblSaveResults.setBounds(12, 12, 161, 15);
		panelCrackingSaveResults.add(lblSaveResults);
		
		saveResultsField = new JTextField();
		saveResultsField.setBounds(98, 39, 167, 19);
		saveResultsField.setColumns(10);
		panelCrackingSaveResults.add(saveResultsField);
		
		btnApply = new JButton("apply");
		btnApply.setBounds(12, 37, 73, 25);
		btnApply.addActionListener(this);
		panelCrackingSaveResults.add(btnApply);
		
		btnStartCracking = new JButton("Start Cracking!");
		btnStartCracking.setBackground(Color.GREEN);
		btnStartCracking.setBounds(12, 428, 253, 25);
		btnStartCracking.addActionListener(this);
		panelCracking.add(btnStartCracking);
		
		JPanel panelCrackingSpecialisation = new JPanel();
		panelCrackingSpecialisation.setLayout(null);
		panelCrackingSpecialisation.setBorder(new BevelBorder(BevelBorder.LOWERED, null, null, null, null));
		panelCrackingSpecialisation.setBounds(0, 245, 277, 159);
		panelCracking.add(panelCrackingSpecialisation);
		
		JLabel lblMcVersion = new JLabel("MC Version:");
		lblMcVersion.setBounds(12, 0, 125, 30);
		panelCrackingSpecialisation.add(lblMcVersion);
		
		JComboBox comboBoxMcVersion = new JComboBox(new DefaultComboBoxModel(new String[] {"1.12.2", "1.16.5"}));
		comboBoxMcVersion.setBounds(155, 3, 110, 24);
		comboBoxMcVersion.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent arg0) {
				JComboBox cb = (JComboBox) arg0.getSource();
				
				if(cb.getSelectedItem().toString() == "1.16.5") mcVersion = EnumMCVersion.V1_16_5;
				if(cb.getSelectedItem().toString() == "1.12.2") mcVersion = EnumMCVersion.V1_12_2;
			}
		});
		panelCrackingSpecialisation.add(comboBoxMcVersion);
		
		JLabel lblLockDirection = new JLabel("Lock direction:");
		lblLockDirection.setBounds(12, 30, 125, 30);
		panelCrackingSpecialisation.add(lblLockDirection);
		
		JComboBox comboBoxDirection = new JComboBox(new DefaultComboBoxModel(new String[] {"unset", "north", "east", "south", "west"}));
		comboBoxDirection.setBounds(155, 34, 110, 24);
		comboBoxDirection.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent arg0) {
				JComboBox cb = (JComboBox) arg0.getSource();
				rotation = EnumRotation.R_ALL;
				String selectedItem = cb.getSelectedItem().toString();
				
				if(selectedItem == "north") rotation = EnumRotation.R0;
				else if(selectedItem == "east") rotation = EnumRotation.R90;
				else if(selectedItem == "south") rotation = EnumRotation.R180;
				else if(selectedItem == "west") rotation = EnumRotation.R270;
			}
		});
		panelCrackingSpecialisation.add(comboBoxDirection);
		
		JLabel yMin = new JLabel("Y minimum:");
		yMin.setBounds(12, 57, 125, 30);
		panelCrackingSpecialisation.add(yMin);
		
		SpinnerModel ySpinnerMinValues = new SpinnerNumberModel(this.yMin, 0, 255, 1);
		ySpinnerMin = new JSpinner(ySpinnerMinValues);
		ySpinnerMin.setBounds(155, 65, 110, 20);
		ySpinnerMin.addChangeListener(new ChangeListener() {

			@Override
			public void stateChanged(ChangeEvent arg0) {
				spinnerStateChangedHandler(arg0);
			}
			
		});
		panelCrackingSpecialisation.add(ySpinnerMin);
		
		JLabel yMax = new JLabel("Y maximum:");
		yMax.setBounds(12, 84, 125, 30);
		panelCrackingSpecialisation.add(yMax);
		
		SpinnerModel ySpinnerMaxValues = new SpinnerNumberModel(this.yMax, 1, 256, 1);
		ySpinnerMax = new JSpinner(ySpinnerMaxValues);
		ySpinnerMax.setBounds(155, 91, 110, 20);
		ySpinnerMax.addChangeListener(new ChangeListener() {

			@Override
			public void stateChanged(ChangeEvent arg0) {
				spinnerStateChangedHandler(arg0);
			}
		});
		panelCrackingSpecialisation.add(ySpinnerMax);
		
		JLabel bruteforceRadiusField = new JLabel("Radius:");
		bruteforceRadiusField.setBounds(12, 111, 125, 30);
		panelCrackingSpecialisation.add(bruteforceRadiusField);
		
		radiusTextField = new JTextField();
		radiusTextField.setBounds(155, 116, 110, 19);
		radiusTextField.setColumns(10);
		radiusTextField.setText(String.valueOf(this.radius));
		radiusTextField.getDocument().addDocumentListener(new DocumentListener() {

			@Override
			public void changedUpdate(DocumentEvent arg0) {}

			@Override
			public void insertUpdate(DocumentEvent arg0) {
				this.validateContent();
			}

			@Override
			public void removeUpdate(DocumentEvent arg0) {
				this.validateContent();
			}
			
			private void validateContent() {
				if(MathHelper.isInteger(radiusTextField.getText())) {
					int r = Integer.valueOf(radiusTextField.getText());
					
					this.removeError();
					
					if(r == 0) this.markError();
					else if(r < 0) this.markError();
					else radius = r;
					
				} else this.markError();
			}
			
			private void markError() {
				validRadius = false;
				radiusTextField.setForeground(Color.RED);
			}
			
			private void removeError() {
				validRadius = true;
				radiusTextField.setForeground(null);
			}
		});
		panelCrackingSpecialisation.add(radiusTextField);
		
		lblProgress = new JLabel("Progress: 0%");
		lblProgress.setBounds(12, 462, 253, 15);
		panelCracking.add(lblProgress);
		
		lblTotalMatches = new JLabel("Total matches: 0");
		lblTotalMatches.setBounds(12, 482, 253, 15);
		panelCracking.add(lblTotalMatches);
		
		JPanel panelUsefulPatternStuff = new JPanel();
		panelUsefulPatternStuff.setLayout(null);
		panelUsefulPatternStuff.setBorder(new BevelBorder(BevelBorder.LOWERED, null, null, null, null));
		panelUsefulPatternStuff.setBounds(489, 12, 277, 543);
		panelMain.add(panelUsefulPatternStuff);
		
		JLabel lblPattern = new JLabel("Pattern");
		lblPattern.setBounds(12, 12, 56, 15);
		panelUsefulPatternStuff.add(lblPattern);
		
		JPanel panelUsefulPatternStuff_load = new JPanel();
		panelUsefulPatternStuff_load.setLayout(null);
		panelUsefulPatternStuff_load.setBorder(new BevelBorder(BevelBorder.LOWERED, null, null, null, null));
		panelUsefulPatternStuff_load.setBounds(0, 35, 277, 100);
		panelUsefulPatternStuff.add(panelUsefulPatternStuff_load);
		
		JLabel lblPatternLoadFile = new JLabel("Load pattern from file:");
		lblPatternLoadFile.setBounds(12, 12, 181, 15);
		panelUsefulPatternStuff_load.add(lblPatternLoadFile);
		
		btnLoadPatternFile = new JButton("Choose file");
		btnLoadPatternFile.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				
				JFileChooser fileChooser = new JFileChooser();
				int action = fileChooser.showOpenDialog(null);
				if(action == JFileChooser.APPROVE_OPTION) {
					
					File loadFile = fileChooser.getSelectedFile();
					System.out.println("Loading from file: " + loadFile);
					applyPatternFromFile(loadFile);
					
					
				}
				
			}
		});
		btnLoadPatternFile.setBounds(12, 39, 165, 25);
		panelUsefulPatternStuff_load.add(btnLoadPatternFile);
		
		JPanel panelUsefulPatternStuff_save = new JPanel();
		panelUsefulPatternStuff_save.setLayout(null);
		panelUsefulPatternStuff_save.setBorder(new BevelBorder(BevelBorder.LOWERED, null, null, null, null));
		panelUsefulPatternStuff_save.setBounds(0, 140, 277, 100);
		panelUsefulPatternStuff.add(panelUsefulPatternStuff_save);
		
		JLabel lblPatternSave = new JLabel("Save Pattern to file:");
		lblPatternSave.setBounds(12, 12, 181, 15);
		panelUsefulPatternStuff_save.add(lblPatternSave);
		
		btnChooseFilename = new JButton("Choose filename");
		btnChooseFilename.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				
				JFileChooser fileChooser = new JFileChooser();
				int action = fileChooser.showSaveDialog(null);
				if(action == JFileChooser.APPROVE_OPTION) {
					
					File saveFile = fileChooser.getSelectedFile();
					System.out.println("Saving to file: " + saveFile);
					savePatternToFile(saveFile);
					
				}
				
			}
		});
		btnChooseFilename.setBounds(12, 39, 165, 25);
		panelUsefulPatternStuff_save.add(btnChooseFilename);
		
		this.renderLayer(1);
	}

	
	/**
	* Renders a layer of the pattern in button matrix
	* layer: layer to render. Starts from 1
	* (Just noticed this is dumb, I'll change that)
	*/
	private void renderLayer(int layer) {
		layer--;
		
		for(int x = 0; x < PATTERN_SIZE; x++) {
			for(int z = 0; z < PATTERN_SIZE; z++) {	
				Vector2 currentButtonPos = new Vector2(x, z);
				Vector3 currentMatrixPos = new Vector3(x, layer, z);
				
				for(JButton b : this.fieldButtons) {
					if((b.getBounds().getX() / 50) == currentButtonPos.getX() && (b.getBounds().getY() / 50) == currentButtonPos.getZ()) {
						this.setIconNumber(b, this.pattern.getValue(currentMatrixPos));
						b.setBorder(null);
					}
				}
			}
		}
	}
	
	
	/**
	* Loads a saved pattern from a file and displays its current layer
	* file: File object representing the pattern file
	*/
	private void applyPatternFromFile(File file) {
		try {		
			Scanner fileReader = new Scanner(file);
			
			Matrix3 tmp = new Matrix3(new Vector3(PATTERN_SIZE, PATTERN_SIZE, PATTERN_SIZE), new Vector3(PATTERN_CENTER, PATTERN_CENTER, PATTERN_CENTER));
			String[] lines = new String[(7*7)+6];
			int line = 0;
			
			while(fileReader.hasNextLine() && line < (7*7)+6) {
				lines[line] = fileReader.nextLine();
				++line;
			}
			
			int currentX = 0;
			int currentY = 0;
			int currentZ = 0;
			
			for(String toParseLine : lines) {
				
				if(toParseLine.contains("-")) {
					++currentY;
					currentX = 0;
					currentZ = 0;
				}
				else {
					String[] zValues = toParseLine.split(" ");
					for(String zValue : zValues) {
						
						tmp.setValue(new Vector3(currentX, currentY, currentZ), Integer.valueOf(zValue));
						++currentZ;
						
					}
					++currentX;
					currentZ = 0;
				}
			}
			
			for(int y = 0; y < PATTERN_SIZE; ++y) {
				this.pattern.setLayer(y, tmp.getLayer(y));
			}
			
			this.renderLayer(this.currentLayer);
			
			fileReader.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
	}
	
	
	/**
	* Saves the current pattern into a file
	* file: File object supplying the name and path for the new file
	*/
	private void savePatternToFile(File file) {
		try {
			if(!file.createNewFile()) {
				System.out.println("File already exists. Overwriting");
			}
			
			FileWriter fileWriter = new FileWriter(file);
			for(int y = 0; y < PATTERN_SIZE; ++y) {
				for(int x = 0; x < PATTERN_SIZE; ++x) {
					for(int z = 0; z < PATTERN_SIZE; ++z) {
						fileWriter.write(pattern.getValue(new Vector3(x, y, z)) + (z == PATTERN_SIZE - 1 ? "" : " "));
					}
					fileWriter.write("\n");
				}
				fileWriter.write("-".repeat((PATTERN_SIZE*2)-1) + "\n");
			}
			fileWriter.close();
			
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	
	/**
	* Sets the icon of a button to one of four availavle ones
	* Used to simulate the rotate texture feature
	* buttonIn: JButton reference to apply the new rotation to
	* icon: icon to be applied to the button (0-4, 4 and else is none)
	*/
	private void setIconNumber(JButton buttonIn, int icon) {
		if(icon == 4) {
			buttonIn.setIcon(null);
			return;
		}
		
		Image img = this.icon_0.getImage();
		if(icon == 1) {
			img = this.icon_1.getImage();
		}
		if(icon == 2) {
			img = this.icon_2.getImage();
		}
		if(icon == 3) {
			img = this.icon_3.getImage();
		}
		Image img_scaled = img.getScaledInstance(buttonIn.getWidth(), buttonIn.getHeight(), java.awt.Image.SCALE_DEFAULT);
		buttonIn.setIcon(new ImageIcon(img_scaled));
	}
	
	
	/**
	* Handle button interactions
	*/
	@Override
	public void actionPerformed(ActionEvent arg0) {
		// Check if it really is a button
		if(arg0.getSource() instanceof JButton) {
			JButton btnIn = (JButton) arg0.getSource();
			
			// Is the button the start cracking button?
			if(btnIn == this.btnStartCracking) {
				if(!this.crackerRunning) {
					if(!this.crackerEnabled || !this.validRadius || !this.validYMin || !this.validYMax) return;
					
					this.crackingStart();
					
					PatternRelative p = new PatternRelative(new Vector3(PATTERN_SIZE, PATTERN_SIZE, PATTERN_SIZE), new Vector3(PATTERN_CENTER, PATTERN_CENTER, PATTERN_CENTER));
					for(int x = 0; x < PATTERN_SIZE; x++) {
						for(int y = 0; y < PATTERN_SIZE; y++) {
							for(int z = 0; z < PATTERN_SIZE; z++) {
								p.canAddToPattern(this.pattern.getValue(new Vector3(x, y, z)));
							}
						}
					}
					p.load();
					
					cb = new CoordinateBruteforcer(p, this.radius, this.yMin, this.yMax, this.mcVersion, this.rotation, this.getInstance(), this.threadCount);
					cb.load();
					
					return;
				}
				
				try{cb.veryVeryBadTermination();} catch(Exception e) {}
				this.crackingEnd();
			}
			
			// To prevent user from messing things up, user is unable to change things while the cracker is running
			if(this.crackerRunning) return;
			
			// Is the button the apply save results file button?
			if(btnIn == this.btnApply) {
				this.saveResultsPath = this.saveResultsField.getText();
			}
			
			// Is the button the set textured button?
			if(btnIn == this.btnSetTextured) {
				for(JButton b : this.fieldButtons) {
					int posX = (int) b.getBounds().getX() / 50;
					int posZ = (int) b.getBounds().getY() / 50;
					
					if(posX == (float) this.activeField.getX() && posZ == (float) this.activeField.getZ()) {
						if(b.getIcon() != null) {
							this.pattern.setValue(new Vector3(posX, this.currentLayer - 1, posZ), 4);
							b.setIcon(null);
							return;
						}
						
						this.pattern.setValue(new Vector3(posX, this.currentLayer - 1, posZ), 0);
						this.setIconNumber(b, 0);
					}
				}
			}
			
			// Is the button the rotate button?
			if(btnIn == this.btnRotateRight) {
				for(JButton b : this.fieldButtons) {
					int posX = (int) b.getBounds().getX() / 50;
					int posZ = (int) b.getBounds().getY() / 50;
					
					if(posX == (float) this.activeField.getX() && posZ == (float) this.activeField.getZ()) {
						Vector3 currentPos = new Vector3(posX, this.currentLayer - 1, posZ);
						int valueOld = this.pattern.getValue(currentPos);
						
						if(valueOld == 0) {
							this.pattern.setValue(currentPos, 1);
							this.setIconNumber(b, 1);
						}
						else if(valueOld == 1) {
							this.pattern.setValue(currentPos, 2);
							this.setIconNumber(b, 2);
						}
						else if(valueOld == 2) {
							this.pattern.setValue(currentPos, 3);
							this.setIconNumber(b, 3);
						}
						else if(valueOld == 3) {
							this.pattern.setValue(currentPos, 0);
							this.setIconNumber(b, 0);
						}
					}
				}
			}
			
			for(JButton b : this.fieldButtons) {
				if(b == btnIn) {
					int posX = (int) btnIn.getBounds().getX() / 50;
					int posZ = (int) btnIn.getBounds().getY() / 50;
					
					this.activeField.setX(posX);
					this.activeField.setZ(posZ);
				}
			}
		}
	}
	
	
	/**
	* Handle JSpinner value changes
	*/
	private void spinnerStateChangedHandler(ChangeEvent arg0) {
		if(arg0.getSource() instanceof JSpinner) {
			JSpinner jsp = (JSpinner) arg0.getSource();
			
			ySpinnerMax.getEditor().getComponent(0).setForeground(null);
			ySpinnerMin.getEditor().getComponent(0).setForeground(null);
			
			if(jsp == ySpinnerMin) {
				this.validYMin = true;
				if(Integer.valueOf(jsp.getValue().toString()) >= Integer.valueOf(ySpinnerMax.getValue().toString())) {
					jsp.getEditor().getComponent(0).setForeground(Color.RED);
					ySpinnerMax.getEditor().getComponent(0).setForeground(Color.RED);
					this.validYMin = false;
				} else this.yMin = Integer.valueOf(jsp.getValue().toString());
			}
			
			if(jsp == ySpinnerMax) {
				this.validYMax = true;
				if(Integer.valueOf(jsp.getValue().toString()) <= Integer.valueOf(ySpinnerMin.getValue().toString())) {
					jsp.getEditor().getComponent(0).setForeground(Color.RED);
					ySpinnerMin.getEditor().getComponent(0).setForeground(Color.RED);
					this.validYMax = false;
				} else this.yMax = Integer.valueOf(jsp.getValue().toString());
			}	
		}
	}

	
	/**
	* Returns main instance
	*/
	public Main getInstance() {
		return instance;
	}
	
	
	/**
	* Visual indication that the cracker is running
	* also initializes the save-file name
	*/
	public void crackingStart() {
		this.initializeSaveFile();
		
		this.lblProgress.setText("Progress: 0%");
		this.lblTotalMatches.setText("Total matches: 0");
		
		this.btnStartCracking.setText("Running...");
		this.btnStartCracking.setBackground(Color.RED);
		this.crackerRunning = true;
	}
	
	
	/**
	* Visual indication that the cracker is done
	*/
	public void crackingEnd() {
		System.out.println("Cracking end");
		this.btnStartCracking.setText("Start Cracking!");
		this.btnStartCracking.setBackground(Color.GREEN);
		this.crackerRunning = false;
	}
	
	
	/**
	* Update value of progress label
	* progress: progress to display (0-100 makes sense)
	*/
	public void updateProgress(int progress) {
		this.lblProgress.setText("Progress: " + progress + "%");
	}
	
	
	/**
	* Update matches count
	*/
	public void updateMatchesCount(int matches) {
		this.lblTotalMatches.setText("Total matches: " + matches);
	}
	
	
	/**
	* Returns the count of threads set by the user
	*/
	public int getThreadCount() {
		return this.threadCount;
	}
	
	
	/**
	* Sets name for the file results will be stored in
	* Sets name to value of lblResultsPath if set
	* Otherwise name is generated using the current date
	*/
	public void initializeSaveFile() {
		if(this.saveResultsPath != null && this.saveResultsPath != "") this.saveResultsPath += (this.saveResultsPath.endsWith(".txt") ? "" : ".txt");
		else {
			DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss");
			LocalDateTime now = LocalDateTime.now();
			
			this.saveResultsPath = "coordinates_" + dtf.format(now) + ".txt";
		}
	}
	
	
	/**
	* Returns name of the save-file
	*/
	public String getSaveFile() {
		return this.saveResultsPath;
	}
}
