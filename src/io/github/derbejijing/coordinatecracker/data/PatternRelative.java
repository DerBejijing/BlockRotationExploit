package io.github.derbejijing.coordinatecracker.data;

import java.util.ArrayList;
import java.util.List;

import io.github.derbejijing.coordinatecracker.math.Matrix3;
import io.github.derbejijing.coordinatecracker.math.Vector3;
import io.github.derbejijing.coordinatecracker.utils.MatrixHelper;

public class PatternRelative {

	public Matrix3 patternMatrix;
	public Matrix3 patternMatrix_90;
	public Matrix3 patternMatrix_180;
	public Matrix3 patternMatrix_270;
	
	public Vector3 center;
	public Vector3 size;
	public Vector3 iterator;
	
	/**
	* PatternRelative constructor
	* size: pattern size
	* center: center of pattern
	*/
	public PatternRelative(Vector3 size, Vector3 center) {
		this.patternMatrix = new Matrix3(size, center);
		this.patternMatrix_90 = new Matrix3(size, center);
		this.patternMatrix_180 = new Matrix3(size, center);
		this.patternMatrix_270 = new Matrix3(size, center);
		
		this.center = center;
		this.size = size;
		
		this.iterator = new Vector3(0, 0, 0);
	}
	
	
	/**
	* Returns true if a value could be added to the pattern
	* Used for "initializing" values of the pattern
	*/
	public boolean canAddToPattern(int value) {
		this.patternMatrix.setValue(iterator, value);
		
		if(iterator.getX() < size.getX() - 1) {
			iterator.incrementX(1);
		}
		else if(iterator.getY() < size.getY() - 1) {
			iterator.setX(0);
			iterator.incrementY(1);
		}
		else if(iterator.getZ() < size.getZ() - 1) {
			iterator.setX(0);
			iterator.setY(0);
			iterator.incrementZ(1);
		}
		else if(iterator.getZ() == size.getZ() - 1) {
			return false;
		}
		return true;
	}
	
	
	/**
	* Sets the pattern to values of a Matrix3 instance
	* reload: set to true if all rotated clones should be updated, too
	*/
	public void setPatternMatrix(Matrix3 patternMatrix, boolean reload) {
		this.patternMatrix = patternMatrix;
		
		if(reload) this.load();
	}
	
	
	/**
	* Sets up rotated clones of the current pattern
	*/
	public void load() {
		this.patternMatrix_90 = MatrixHelper.rotateMatrix(new Matrix3(this.patternMatrix), EnumRotation.R90);
		this.patternMatrix_90 = swapValues(new Matrix3(this.patternMatrix_90));		
		
		this.patternMatrix_180 = MatrixHelper.rotateMatrix(this.patternMatrix_90, EnumRotation.R180);
		this.patternMatrix_180 = swapValues(this.patternMatrix_180);
		
		this.patternMatrix_270 = MatrixHelper.rotateMatrix(this.patternMatrix_180, EnumRotation.R270);
		this.patternMatrix_270 = swapValues(this.patternMatrix_270);
	}
	
	
	/**
	* Returns the pattern as a Matrix3 instance
	* rotation: direction pattern should be rotated towards
	*/
	public Matrix3 getPatternMatrix(EnumRotation rotation) {
		switch(rotation) {
		case R0: return this.patternMatrix;
		case R90: return this.patternMatrix_90;
		case R180: return this.patternMatrix_180;
		case R270: return this.patternMatrix_270;
		default: return null;
		}
	}
	
	
	/**
	* Returns an ArrayList of the pattern and its rotated clones
	*/
	public List<Matrix3> getPatterns() {
		List<Matrix3> listOut = new ArrayList<>();
		
		listOut.add(patternMatrix);
		listOut.add(patternMatrix_90);
		listOut.add(patternMatrix_180);
		listOut.add(patternMatrix_270);
		
		return listOut;
	}
	
	
	/**
	* I don't know what this used to do
	*/
	private Matrix3 swapValues(Matrix3 matrixIn) {
		Matrix3 matrixOut = new Matrix3(matrixIn);
		
		for(int x = 0; x < matrixOut.getSizeX(); x++) {
			for(int y = 0; y < matrixOut.getSizeY(); y++) {
				for(int z = 0; z < matrixOut.getSizeZ(); z++) {
					
					Vector3 pos = new Vector3(x, y, z);
					
					if(matrixOut.getValue(pos) == 0) matrixOut.setValue(pos, 1);
					else if(matrixOut.getValue(pos) == 1) matrixOut.setValue(pos, 2);
					else if(matrixOut.getValue(pos) == 2) matrixOut.setValue(pos, 3);
					else if(matrixOut.getValue(pos) == 3) matrixOut.setValue(pos, 0);
					
				}
			}
		}
		
		return matrixOut;
	}
	
}
